{"version":3,"sources":["../../../core/packages/core/dist/esm lazy /^/.//.*/.entry/.js$/ include: //.entry/.js$/ exclude: //.system/.entry/.js$/ groupOptions: {} namespace object","../../../core/packages/core/dist/esm/loader.js","../../../core/packages/core/loader/index.js","../../src/components/cui-button.component.jsx","App.js","index.js","../../../core/packages/core/dist/esm/polyfills/index.js","../../src/setup.js","../../../core/packages/core/dist/esm/index-34661786.js"],"names":["map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","keys","Object","module","exports","defineCustomElements","win","options","window","promiseResolve","bootstrapLazy","Reflect","customElements","a","HTMLElement","construct","this","constructor","prototype","setPrototypeOf","CuiButton","children","props","outline","color","pill","square","circle","onClick","colors","App","console","log","className","href","target","rel","key","ReactDOM","render","document","getElementById","promises","Element","closest","matches","remove","getRootNode","push","assign","entries","Array","find","includes","String","startsWith","endsWith","NodeList","forEach","fetch","u","URL","pathname","searchParams","checkIfURLIsSupported","WeakMap","all","applyPolyfills","contentRef","hostTagName","useNativeShadowDom","checkSlotFallbackVisibility","checkSlotRelocate","queuePending","doc","head","plt","$flags$","$resourcesUrl$","jmp","h","raf","requestAnimationFrame","ael","el","eventName","listener","opts","addEventListener","removeEventListener","ce","CustomEvent","v","addHostEventListeners","elm","hostRef","listeners","attachParentListeners","flags","name","method","handler","hostListenerProxy","hostListenerOpts","$rmListeners$","methodName","ev","$lazyInstance$","$queuedListeners$","consoleError","HYDRATED_CSS","EMPTY_OBJ","isComplexType","nodeName","vnodeData","child","slotName","simple","lastSimple","vNodeChildren","walk","c","i","length","isArray","$text$","newVNode","classData","class","filter","k","join","vnode","$attrs$","$children$","$name$","tag","text","$tag$","$elm$","Host","setAccessor","memberName","oldValue","newValue","isSvg","isProp","isMemberInElement","toLowerCase","classList","oldClasses","parseClassList","newClasses","add","isComplex","tagName","n","getAttribute","removeAttribute","setAttribute","parseClassListRegex","value","split","updateElement","oldVnode","newVnode","isSvgMode","nodeType","host","oldVnodeAttrs","newVnodeAttrs","undefined","createElm","oldParentVNode","newParentVNode","childIndex","parentElm","childNode","oldVNode","createTextNode","createElement","appendChild","putBackInOriginalLocation","recursive","oldSlotChildNodes","childNodes","parentReferenceNode","insertBefore","referenceNode","addVnodes","before","parentVNode","vnodes","startIdx","endIdx","containerElm","parentNode","removeVnodes","updateChildren","oldCh","newCh","node","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","isSameVnode","patch","nextSibling","vnode1","vnode2","oldChildren","newChildren","relocateNodes","isNodeLocatedInSlot","nodeToRelocate","slotNameAttr","renderVdom","renderFnResults","hostElm","$hostElement$","cmpMeta","$cmpMeta$","$vnode$","rootVnode","relocateData","orgLocationNode","parentNodeRef","insertBeforeNode","refNode","relocateSlotContent","hostContentNodes","relocateNodeData","j","ilen","r","$nodeToRelocate$","$slotRefNode$","relocateNode","some","previousSibling","hidden","updateFallbackSlotVisibility","textContent","trim","getElement","ref","getHostRef","attachToAncestor","ancestorComponent","$onRenderResolve$","scheduleUpdate","isInitialLoad","$ancestorComponent$","writeTask","dispatchHooks","endSchedule","$tagName$","instance","event","safeCall","promise","updateComponent","endUpdate","rc","endRender","callRender","cb","childrenPromises","postUpdate","postUpdateComponent","endPostUpdate","addHydratedFlag","$onReadyResolve$","appDidLoad","nextTick","who","documentElement","dispatchEvent","emitEvent","detail","namespace","arg","thenFn","setValue","propName","newVal","propValue","propType","oldVal","$instanceValues$","get","$members$","set","proxyComponent","Cstr","members","memberFlags","defineProperty","configurable","enumerable","attrNameToPropName","Map","attributeChangedCallback","attrName","_oldValue","observedAttributes","initializeComponent","hmrVersionId","loadModule","endLoad","isProxied","endNewInstance","schedule","connectedCallback","endConnected","$listeners$","setContentReference","hasOwnProperty","contentRefElm","createComment","firstChild","disconnectedCallback","rmListener","lazyBundles","appLoadFallback","endBootstrap","cmpTags","exclude","metaCharset","querySelector","visibilityStyle","deferredConnectedCallbacks","isBootstrapping","resourcesUrl","baseURI","lazyBundle","compactMeta","HostElement","self","registerHost","clearTimeout","$onReadyPromise$","$lazyBundleId$","define","innerHTML","setTimeout","hostRefs","registerInstance","lazyInstance","error","cmpModules","exportName","replace","bundleId","importedModule","queueDomReads","queueDomWrites","queueTask","queue","write","flush","consume","performance","now"],"mappings":"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","file":"static/js/main.82cced44.chunk.js","sourcesContent":["var map = {\n\t\"./cross-button.entry.js\": [\n\t\t29,\n\t\t5\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(function() {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 26;\nmodule.exports = webpackAsyncContext;","import { p as promiseResolve, b as bootstrapLazy } from './index-34661786.js';\n\n/*\n Stencil Client Patch Esm v2.6.0 | MIT Licensed | https://stenciljs.com\n */\nconst patchEsm = () => {\n    return promiseResolve();\n};\n\nconst defineCustomElements = (win, options) => {\n  if (typeof window === 'undefined') return Promise.resolve();\n  return patchEsm().then(() => {\n  return bootstrapLazy([[\"cross-button\",[[4,\"cross-button\",{\"outline\":[1028],\"disabled\":[1028],\"color\":[1],\"size\":[1],\"circle\":[4],\"square\":[4],\"pill\":[4],\"fullWidth\":[4,\"full-width\"],\"selected\":[4],\"type\":[1]},[[2,\"click\",\"onClickHandler\"]]]]]], options);\n  });\n};\n\nexport { defineCustomElements };\n","\n(function(){if(\"undefined\"!==typeof window&&void 0!==window.Reflect&&void 0!==window.customElements){var a=HTMLElement;window.HTMLElement=function(){return Reflect.construct(a,[],this.constructor)};HTMLElement.prototype=a.prototype;HTMLElement.prototype.constructor=HTMLElement;Object.setPrototypeOf(HTMLElement,a)}})();\nexport * from '../dist/esm/polyfills/index.js';\nexport * from '../dist/esm/loader.js';\n","import React from 'react'\n\nexport const CuiButton = ({ children, ...props }) => {\n  const { outline, color, pill, square, circle, onClick } = props\n\n  return (\n    <cross-button\n      color={color}\n      outline={outline}\n      pill={pill}\n      square={square}\n      circle={circle}\n      onClick={onClick}\n    >\n      {children}\n    </cross-button>\n  )\n}\n","import React from 'react'\n\nimport { CuiButton } from '@cross-ui/react'\n\nimport './App.scss';\n\nconst colors = ['primary', 'secondary', 'accent', 'danger', 'warning', 'success', 'info'];\n\nconst App = () => {\n  function onClick() {\n    console.log(\"onClick\")\n  }\n\n  return (<div className=\"flex flex-col\">\n    <div\n      className=\"ForkMeOnGithub fixed top-0 right-0 mt-10 -mr-12 transform rotate-45 bg-gray-900 z-10\"\n    >\n      <a\n        href=\"https://github.com/dimaslz/cross-ui-react\"\n        target=\"_blank\"\n        className=\"flex text-gray-300 hover:text-gray-100 px-10 py-1 border border-white my-1 border-dashed\"\n        rel=\"noopener noreferrer\"\n      >\n        Fork me on GitHub\n      </a>\n    </div>\n\n    <div className=\"p-10\">\n      <h1\n        className=\"my-4 text-2xl\"\n      >\n        Demo button using @cross-ui/react library based on @cross-ui/core\n      </h1>\n\n      <div>\n        <div>\n          {colors.map((color, key) => <CuiButton color={color} key={key} onClick={onClick}>{color}</CuiButton>)}\n        </div>\n        <div>\n          {colors.map((color, key) => <CuiButton color={color} key={key} outline onClick={onClick}>{color}</CuiButton>)}\n        </div>\n        <div>\n          {colors.map((color, key) => <CuiButton color={color} square={true} key={key} onClick={onClick}>?</CuiButton>)}\n        </div>\n        <div>\n          {colors.map((color, key) => <CuiButton color={color} square={true} key={key} outline onClick={onClick}>?</CuiButton>)}\n        </div>\n        <div>\n          {colors.map((color, key) => <CuiButton color={color} pill={true} key={key} onClick={onClick}>{color}</CuiButton>)}\n        </div>\n        <div>\n          {colors.map((color, key) => <CuiButton color={color} pill={true} key={key} outline onClick={onClick}>{color}</CuiButton>)}\n        </div>\n        <div>\n          {colors.map((color, key) => <CuiButton color={color} circle={true} key={key} onClick={onClick}>?</CuiButton>)}\n        </div>\n        <div>\n          {colors.map((color, key) => <CuiButton color={color} circle={true} key={key} outline onClick={onClick}>?</CuiButton>)}\n        </div>\n      </div>\n    </div>\n  </div>)\n}\n\nexport default App\n","import './index.scss'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nimport { InitCrossUIReact } from '@cross-ui/react'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\nInitCrossUIReact();","export function applyPolyfills() {\n  var promises = [];\n  if (typeof window !== 'undefined') {\n    var win = window;\n\n    if (!win.customElements ||\n      (win.Element && (!win.Element.prototype.closest || !win.Element.prototype.matches || !win.Element.prototype.remove || !win.Element.prototype.getRootNode))) {\n      promises.push(import(/* webpackChunkName: \"polyfills-dom\" */ './dom.js'));\n    }\n\n    var checkIfURLIsSupported = function() {\n      try {\n        var u = new URL('b', 'http://a');\n        u.pathname = 'c%20d';\n        return (u.href === 'http://a/c%20d') && u.searchParams;\n      } catch (e) {\n        return false;\n      }\n    };\n\n    if (\n      'function' !== typeof Object.assign || !Object.entries ||\n      !Array.prototype.find || !Array.prototype.includes ||\n      !String.prototype.startsWith || !String.prototype.endsWith ||\n      (win.NodeList && !win.NodeList.prototype.forEach) ||\n      !win.fetch ||\n      !checkIfURLIsSupported() ||\n      typeof WeakMap == 'undefined'\n    ) {\n      promises.push(import(/* webpackChunkName: \"polyfills-core-js\" */ './core-js.js'));\n    }\n  }\n  return Promise.all(promises);\n}\n","import { applyPolyfills, defineCustomElements } from '@cross-ui/core/loader'\n\nexport const setup = () => {\n  applyPolyfills().then(() => {\n    defineCustomElements()\n  })\n}\n","const NAMESPACE = 'cross-ui';\n\nlet contentRef;\nlet hostTagName;\nlet useNativeShadowDom = false;\nlet checkSlotFallbackVisibility = false;\nlet checkSlotRelocate = false;\nlet isSvgMode = false;\nlet queuePending = false;\nconst win = typeof window !== 'undefined' ? window : {};\nconst doc = win.document || { head: {} };\nconst plt = {\n    $flags$: 0,\n    $resourcesUrl$: '',\n    jmp: h => h(),\n    raf: h => requestAnimationFrame(h),\n    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n    ce: (eventName, opts) => new CustomEvent(eventName, opts),\n};\nconst promiseResolve = (v) => Promise.resolve(v);\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n    if (listeners) {\n        listeners.map(([flags, name, method]) => {\n            const target = elm;\n            const handler = hostListenerProxy(hostRef, method);\n            const opts = hostListenerOpts(flags);\n            plt.ael(target, name, handler, opts);\n            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n        });\n    }\n};\nconst hostListenerProxy = (hostRef, methodName) => (ev) => {\n    try {\n        {\n            if (hostRef.$flags$ & 256 /* isListenReady */) {\n                // instance is ready, let's call it's member method for this event\n                hostRef.$lazyInstance$[methodName](ev);\n            }\n            else {\n                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n            }\n        }\n    }\n    catch (e) {\n        consoleError(e);\n    }\n};\n// prettier-ignore\nconst hostListenerOpts = (flags) => (flags & 2 /* Capture */) !== 0;\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst createTime = (fnName, tagName = '') => {\n    {\n        return () => {\n            return;\n        };\n    }\n};\nconst uniqueTime = (key, measureText) => {\n    {\n        return () => {\n            return;\n        };\n    }\n};\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\nconst isComplexType = (o) => {\n    // https://jsperf.com/typeof-fn-object/5\n    o = typeof o;\n    return o === 'object' || o === 'function';\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n    let child = null;\n    let slotName = null;\n    let simple = false;\n    let lastSimple = false;\n    let vNodeChildren = [];\n    const walk = (c) => {\n        for (let i = 0; i < c.length; i++) {\n            child = c[i];\n            if (Array.isArray(child)) {\n                walk(child);\n            }\n            else if (child != null && typeof child !== 'boolean') {\n                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {\n                    child = String(child);\n                }\n                if (simple && lastSimple) {\n                    // If the previous child was simple (string), we merge both\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n                }\n                else {\n                    // Append a new vNode, if it's text, we create a text vNode\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\n                }\n                lastSimple = simple;\n            }\n        }\n    };\n    walk(children);\n    if (vnodeData) {\n        if (vnodeData.name) {\n            slotName = vnodeData.name;\n        }\n        {\n            const classData = vnodeData.className || vnodeData.class;\n            if (classData) {\n                vnodeData.class =\n                    typeof classData !== 'object'\n                        ? classData\n                        : Object.keys(classData)\n                            .filter(k => classData[k])\n                            .join(' ');\n            }\n        }\n    }\n    const vnode = newVNode(nodeName, null);\n    vnode.$attrs$ = vnodeData;\n    if (vNodeChildren.length > 0) {\n        vnode.$children$ = vNodeChildren;\n    }\n    {\n        vnode.$name$ = slotName;\n    }\n    return vnode;\n};\nconst newVNode = (tag, text) => {\n    const vnode = {\n        $flags$: 0,\n        $tag$: tag,\n        $text$: text,\n        $elm$: null,\n        $children$: null,\n    };\n    {\n        vnode.$attrs$ = null;\n    }\n    {\n        vnode.$name$ = null;\n    }\n    return vnode;\n};\nconst Host = {};\nconst isHost = (node) => node && node.$tag$ === Host;\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n    if (oldValue !== newValue) {\n        let isProp = isMemberInElement(elm, memberName);\n        memberName.toLowerCase();\n        if (memberName === 'class') {\n            const classList = elm.classList;\n            const oldClasses = parseClassList(oldValue);\n            const newClasses = parseClassList(newValue);\n            classList.remove(...oldClasses.filter(c => c && !newClasses.includes(c)));\n            classList.add(...newClasses.filter(c => c && !oldClasses.includes(c)));\n        }\n        else {\n            // Set property if it exists and it's not a SVG\n            const isComplex = isComplexType(newValue);\n            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\n                try {\n                    if (!elm.tagName.includes('-')) {\n                        let n = newValue == null ? '' : newValue;\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n                        if (memberName === 'list') {\n                            isProp = false;\n                            // tslint:disable-next-line: triple-equals\n                        }\n                        else if (oldValue == null || elm[memberName] != n) {\n                            elm[memberName] = n;\n                        }\n                    }\n                    else {\n                        elm[memberName] = newValue;\n                    }\n                }\n                catch (e) { }\n            }\n            if (newValue == null || newValue === false) {\n                if (newValue !== false || elm.getAttribute(memberName) === '') {\n                    {\n                        elm.removeAttribute(memberName);\n                    }\n                }\n            }\n            else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {\n                newValue = newValue === true ? '' : newValue;\n                {\n                    elm.setAttribute(memberName, newValue);\n                }\n            }\n        }\n    }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n    // if the element passed in is a shadow root, which is a document fragment\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\n    // if it's not a shadow root, then we add attrs/props to the same element\n    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n    {\n        // remove attributes no longer present on the vnode by setting them to undefined\n        for (memberName in oldVnodeAttrs) {\n            if (!(memberName in newVnodeAttrs)) {\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n            }\n        }\n    }\n    // add new & update changed attributes\n    for (memberName in newVnodeAttrs) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n    }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n    // tslint:disable-next-line: prefer-const\n    let newVNode = newParentVNode.$children$[childIndex];\n    let i = 0;\n    let elm;\n    let childNode;\n    let oldVNode;\n    if (!useNativeShadowDom) {\n        // remember for later we need to check to relocate nodes\n        checkSlotRelocate = true;\n        if (newVNode.$tag$ === 'slot') {\n            newVNode.$flags$ |= newVNode.$children$\n                ? // slot element has fallback content\n                    2 /* isSlotFallback */\n                : // slot element does not have fallback content\n                    1 /* isSlotReference */;\n        }\n    }\n    if (newVNode.$flags$ & 1 /* isSlotReference */) {\n        // create a slot reference node\n        elm = newVNode.$elm$ = doc.createTextNode('');\n    }\n    else {\n        // create element\n        elm = newVNode.$elm$ = (doc.createElement(newVNode.$flags$ & 2 /* isSlotFallback */ ? 'slot-fb' : newVNode.$tag$));\n        // add css classes, attrs, props, listeners, etc.\n        {\n            updateElement(null, newVNode, isSvgMode);\n        }\n        if (newVNode.$children$) {\n            for (i = 0; i < newVNode.$children$.length; ++i) {\n                // create the node\n                childNode = createElm(oldParentVNode, newVNode, i);\n                // return node could have been null\n                if (childNode) {\n                    // append our new node\n                    elm.appendChild(childNode);\n                }\n            }\n        }\n    }\n    {\n        elm['s-hn'] = hostTagName;\n        if (newVNode.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {\n            // remember the content reference comment\n            elm['s-sr'] = true;\n            // remember the content reference comment\n            elm['s-cr'] = contentRef;\n            // remember the slot name, or empty string for default slot\n            elm['s-sn'] = newVNode.$name$ || '';\n            // check if we've got an old vnode for this slot\n            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n                // we've got an old slot vnode and the wrapper is being replaced\n                // so let's move the old slot content back to it's original location\n                putBackInOriginalLocation(oldParentVNode.$elm$, false);\n            }\n        }\n    }\n    return elm;\n};\nconst putBackInOriginalLocation = (parentElm, recursive) => {\n    plt.$flags$ |= 1 /* isTmpDisconnected */;\n    const oldSlotChildNodes = parentElm.childNodes;\n    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {\n        const childNode = oldSlotChildNodes[i];\n        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {\n            // // this child node in the old element is from another component\n            // // remove this node from the old slot's parent\n            // childNode.remove();\n            // and relocate it back to it's original location\n            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\n            // remove the old original location comment entirely\n            // later on the patch function will know what to do\n            // and move this to the correct spot in need be\n            childNode['s-ol'].remove();\n            childNode['s-ol'] = undefined;\n            checkSlotRelocate = true;\n        }\n        if (recursive) {\n            putBackInOriginalLocation(childNode, recursive);\n        }\n    }\n    plt.$flags$ &= ~1 /* isTmpDisconnected */;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n    let containerElm = ((parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);\n    let childNode;\n    for (; startIdx <= endIdx; ++startIdx) {\n        if (vnodes[startIdx]) {\n            childNode = createElm(null, parentVNode, startIdx);\n            if (childNode) {\n                vnodes[startIdx].$elm$ = childNode;\n                containerElm.insertBefore(childNode, referenceNode(before) );\n            }\n        }\n    }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n    for (; startIdx <= endIdx; ++startIdx) {\n        if ((vnode = vnodes[startIdx])) {\n            elm = vnode.$elm$;\n            {\n                // we're removing this element\n                // so it's possible we need to show slot fallback content now\n                checkSlotFallbackVisibility = true;\n                if (elm['s-ol']) {\n                    // remove the original location comment\n                    elm['s-ol'].remove();\n                }\n                else {\n                    // it's possible that child nodes of the node\n                    // that's being removed are slot nodes\n                    putBackInOriginalLocation(elm, true);\n                }\n            }\n            // remove the vnode's element from the dom\n            elm.remove();\n        }\n    }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let node;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n            // Vnode might have been moved left\n            oldStartVnode = oldCh[++oldStartIdx];\n        }\n        else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            if ((oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n            }\n            patch(oldStartVnode, newEndVnode);\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            if ((oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n            }\n            patch(oldEndVnode, newStartVnode);\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            {\n                // new element\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            if (node) {\n                {\n                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n                }\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n    }\n    else if (newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n};\nconst isSameVnode = (vnode1, vnode2) => {\n    // compare if two vnode to see if they're \"technically\" the same\n    // need to have the same element tag, and same key to be the same\n    if (vnode1.$tag$ === vnode2.$tag$) {\n        if (vnode1.$tag$ === 'slot') {\n            return vnode1.$name$ === vnode2.$name$;\n        }\n        return true;\n    }\n    return false;\n};\nconst referenceNode = (node) => {\n    // this node was relocated to a new location in the dom\n    // because of some other component's slot\n    // but we still have an html comment in place of where\n    // it's original location was according to it's original vdom\n    return (node && node['s-ol']) || node;\n};\nconst parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;\nconst patch = (oldVNode, newVNode) => {\n    const elm = (newVNode.$elm$ = oldVNode.$elm$);\n    const oldChildren = oldVNode.$children$;\n    const newChildren = newVNode.$children$;\n    const tag = newVNode.$tag$;\n    {\n        // element node\n        {\n            if (tag === 'slot')\n                ;\n            else {\n                // either this is the first render of an element OR it's an update\n                // AND we already know it's possible it could have changed\n                // this updates the element's css classes, attrs, props, listeners, etc.\n                updateElement(oldVNode, newVNode, isSvgMode);\n            }\n        }\n        if (oldChildren !== null && newChildren !== null) {\n            // looks like there's child vnodes for both the old and new vnodes\n            updateChildren(elm, oldChildren, newVNode, newChildren);\n        }\n        else if (newChildren !== null) {\n            // add the new vnode children\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n        }\n        else if (oldChildren !== null) {\n            // no new child vnodes, but there are old child vnodes to remove\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\n        }\n    }\n};\nconst updateFallbackSlotVisibility = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNodes = elm.childNodes;\n    let childNode;\n    let i;\n    let ilen;\n    let j;\n    let slotNameAttr;\n    let nodeType;\n    for (i = 0, ilen = childNodes.length; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            if (childNode['s-sr']) {\n                // this is a slot fallback node\n                // get the slot name for this slot reference node\n                slotNameAttr = childNode['s-sn'];\n                // by default always show a fallback slot node\n                // then hide it if there are other slots in the light dom\n                childNode.hidden = false;\n                for (j = 0; j < ilen; j++) {\n                    nodeType = childNodes[j].nodeType;\n                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {\n                        // this sibling node is from a different component OR is a named fallback slot node\n                        if (nodeType === 1 /* ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                    else {\n                        // this is a default fallback slot node\n                        // any element or text node (with content)\n                        // should hide the default fallback slot node\n                        if (nodeType === 1 /* ElementNode */ ||\n                            (nodeType === 3 /* TextNode */ && childNodes[j].textContent.trim() !== '')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            // keep drilling down\n            updateFallbackSlotVisibility(childNode);\n        }\n    }\n};\nconst relocateNodes = [];\nconst relocateSlotContent = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNode;\n    let node;\n    let hostContentNodes;\n    let slotNameAttr;\n    let relocateNodeData;\n    let j;\n    let i = 0;\n    let childNodes = elm.childNodes;\n    let ilen = childNodes.length;\n    for (; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {\n            // first got the content reference comment node\n            // then we got it's parent, which is where all the host content is in now\n            hostContentNodes = node.parentNode.childNodes;\n            slotNameAttr = childNode['s-sn'];\n            for (j = hostContentNodes.length - 1; j >= 0; j--) {\n                node = hostContentNodes[j];\n                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {\n                    // let's do some relocating to its new home\n                    // but never relocate a content reference node\n                    // that is suppose to always represent the original content location\n                    if (isNodeLocatedInSlot(node, slotNameAttr)) {\n                        // it's possible we've already decided to relocate this node\n                        relocateNodeData = relocateNodes.find(r => r.$nodeToRelocate$ === node);\n                        // made some changes to slots\n                        // let's make sure we also double check\n                        // fallbacks are correctly hidden or shown\n                        checkSlotFallbackVisibility = true;\n                        node['s-sn'] = node['s-sn'] || slotNameAttr;\n                        if (relocateNodeData) {\n                            // previously we never found a slot home for this node\n                            // but turns out we did, so let's remember it now\n                            relocateNodeData.$slotRefNode$ = childNode;\n                        }\n                        else {\n                            // add to our list of nodes to relocate\n                            relocateNodes.push({\n                                $slotRefNode$: childNode,\n                                $nodeToRelocate$: node,\n                            });\n                        }\n                        if (node['s-sr']) {\n                            relocateNodes.map(relocateNode => {\n                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {\n                                    relocateNodeData = relocateNodes.find(r => r.$nodeToRelocate$ === node);\n                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (!relocateNodes.some(r => r.$nodeToRelocate$ === node)) {\n                        // so far this element does not have a slot home, not setting slotRefNode on purpose\n                        // if we never find a home for this element then we'll need to hide it\n                        relocateNodes.push({\n                            $nodeToRelocate$: node,\n                        });\n                    }\n                }\n            }\n        }\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            relocateSlotContent(childNode);\n        }\n    }\n};\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {\n    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {\n            return true;\n        }\n        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {\n            return true;\n        }\n        return false;\n    }\n    if (nodeToRelocate['s-sn'] === slotNameAttr) {\n        return true;\n    }\n    return slotNameAttr === '';\n};\nconst renderVdom = (hostRef, renderFnResults) => {\n    const hostElm = hostRef.$hostElement$;\n    const cmpMeta = hostRef.$cmpMeta$;\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n    hostTagName = hostElm.tagName;\n    rootVnode.$tag$ = null;\n    rootVnode.$flags$ |= 4 /* isHost */;\n    hostRef.$vnode$ = rootVnode;\n    rootVnode.$elm$ = oldVNode.$elm$ = (hostElm);\n    {\n        contentRef = hostElm['s-cr'];\n        useNativeShadowDom = (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;\n        // always reset\n        checkSlotFallbackVisibility = false;\n    }\n    // synchronous patch\n    patch(oldVNode, rootVnode);\n    {\n        // while we're moving nodes around existing nodes, temporarily disable\n        // the disconnectCallback from working\n        plt.$flags$ |= 1 /* isTmpDisconnected */;\n        if (checkSlotRelocate) {\n            relocateSlotContent(rootVnode.$elm$);\n            let relocateData;\n            let nodeToRelocate;\n            let orgLocationNode;\n            let parentNodeRef;\n            let insertBeforeNode;\n            let refNode;\n            let i = 0;\n            for (; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (!nodeToRelocate['s-ol']) {\n                    // add a reference node marking this node's original location\n                    // keep a reference to this node for later lookups\n                    orgLocationNode = doc.createTextNode('');\n                    orgLocationNode['s-nr'] = nodeToRelocate;\n                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);\n                }\n            }\n            for (i = 0; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (relocateData.$slotRefNode$) {\n                    // by default we're just going to insert it directly\n                    // after the slot reference node\n                    parentNodeRef = relocateData.$slotRefNode$.parentNode;\n                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\n                    orgLocationNode = nodeToRelocate['s-ol'];\n                    while ((orgLocationNode = orgLocationNode.previousSibling)) {\n                        refNode = orgLocationNode['s-nr'];\n                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {\n                            refNode = refNode.nextSibling;\n                            if (!refNode || !refNode['s-nr']) {\n                                insertBeforeNode = refNode;\n                                break;\n                            }\n                        }\n                    }\n                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) || nodeToRelocate.nextSibling !== insertBeforeNode) {\n                        // we've checked that it's worth while to relocate\n                        // since that the node to relocate\n                        // has a different next sibling or parent relocated\n                        if (nodeToRelocate !== insertBeforeNode) {\n                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {\n                                // probably a component in the index.html that doesn't have it's hostname set\n                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;\n                            }\n                            // add it back to the dom but in its new home\n                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\n                        }\n                    }\n                }\n                else {\n                    // this node doesn't have a slot home to go to, so let's hide it\n                    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n                        nodeToRelocate.hidden = true;\n                    }\n                }\n            }\n        }\n        if (checkSlotFallbackVisibility) {\n            updateFallbackSlotVisibility(rootVnode.$elm$);\n        }\n        // done moving nodes around\n        // allow the disconnect callback to work again\n        plt.$flags$ &= ~1 /* isTmpDisconnected */;\n        // always reset\n        relocateNodes.length = 0;\n    }\n};\nconst getElement = (ref) => (getHostRef(ref).$hostElement$ );\nconst emitEvent = (elm, name, opts) => {\n    const ev = plt.ce(name, opts);\n    elm.dispatchEvent(ev);\n    return ev;\n};\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n    if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {\n        ancestorComponent['s-p'].push(new Promise(r => (hostRef.$onRenderResolve$ = r)));\n    }\n};\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\n    {\n        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n    }\n    if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n        hostRef.$flags$ |= 512 /* needsRerender */;\n        return;\n    }\n    attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n    // there is no ancestor component or the ancestor component\n    // has already fired off its lifecycle update then\n    // fire off the initial update\n    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n    return writeTask(dispatch) ;\n};\nconst dispatchHooks = (hostRef, isInitialLoad) => {\n    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);\n    const instance = hostRef.$lazyInstance$ ;\n    let promise;\n    if (isInitialLoad) {\n        {\n            hostRef.$flags$ |= 256 /* isListenReady */;\n            if (hostRef.$queuedListeners$) {\n                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));\n                hostRef.$queuedListeners$ = null;\n            }\n        }\n    }\n    endSchedule();\n    return then(promise, () => updateComponent(hostRef, instance));\n};\nconst updateComponent = async (hostRef, instance, isInitialLoad) => {\n    // updateComponent\n    const elm = hostRef.$hostElement$;\n    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);\n    const rc = elm['s-rc'];\n    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);\n    {\n        callRender(hostRef, instance);\n    }\n    if (rc) {\n        // ok, so turns out there are some child host elements\n        // waiting on this parent element to load\n        // let's fire off all update callbacks waiting\n        rc.map(cb => cb());\n        elm['s-rc'] = undefined;\n    }\n    endRender();\n    endUpdate();\n    {\n        const childrenPromises = elm['s-p'];\n        const postUpdate = () => postUpdateComponent(hostRef);\n        if (childrenPromises.length === 0) {\n            postUpdate();\n        }\n        else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n            childrenPromises.length = 0;\n        }\n    }\n};\nconst callRender = (hostRef, instance, elm) => {\n    try {\n        instance = instance.render() ;\n        {\n            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n        }\n        {\n            hostRef.$flags$ |= 2 /* hasRendered */;\n        }\n        {\n            {\n                // looks like we've got child nodes to render into this host element\n                // or we need to update the css class/attrs on the host element\n                // DOM WRITE!\n                {\n                    renderVdom(hostRef, instance);\n                }\n            }\n        }\n    }\n    catch (e) {\n        consoleError(e, hostRef.$hostElement$);\n    }\n    return null;\n};\nconst postUpdateComponent = (hostRef) => {\n    const tagName = hostRef.$cmpMeta$.$tagName$;\n    const elm = hostRef.$hostElement$;\n    const endPostUpdate = createTime('postUpdate', tagName);\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n        hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n        {\n            // DOM WRITE!\n            addHydratedFlag(elm);\n        }\n        endPostUpdate();\n        {\n            hostRef.$onReadyResolve$(elm);\n            if (!ancestorComponent) {\n                appDidLoad();\n            }\n        }\n    }\n    else {\n        endPostUpdate();\n    }\n    // load events fire from bottom to top\n    // the deepest elements load first then bubbles up\n    {\n        if (hostRef.$onRenderResolve$) {\n            hostRef.$onRenderResolve$();\n            hostRef.$onRenderResolve$ = undefined;\n        }\n        if (hostRef.$flags$ & 512 /* needsRerender */) {\n            nextTick(() => scheduleUpdate(hostRef, false));\n        }\n        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n    }\n    // ( •_•)\n    // ( •_•)>⌐■-■\n    // (⌐■_■)\n};\nconst appDidLoad = (who) => {\n    // on appload\n    // we have finish the first big initial render\n    {\n        addHydratedFlag(doc.documentElement);\n    }\n    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));\n};\nconst safeCall = (instance, method, arg) => {\n    if (instance && instance[method]) {\n        try {\n            return instance[method](arg);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    return undefined;\n};\nconst then = (promise, thenFn) => {\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst addHydratedFlag = (elm) => (elm.classList.add('hydrated') );\nconst parsePropertyValue = (propValue, propType) => {\n    // ensure this value is of the correct prop type\n    if (propValue != null && !isComplexType(propValue)) {\n        if (propType & 4 /* Boolean */) {\n            // per the HTML spec, any string value means it is a boolean true value\n            // but we'll cheat here and say that the string \"false\" is the boolean false\n            return propValue === 'false' ? false : propValue === '' || !!propValue;\n        }\n        if (propType & 1 /* String */) {\n            // could have been passed as a number or boolean\n            // but we still want it as a string\n            return String(propValue);\n        }\n        // redundant return here for better minification\n        return propValue;\n    }\n    // not sure exactly what type we want\n    // so no need to change to a different type\n    return propValue;\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n    // check our new property value against our internal value\n    const hostRef = getHostRef(ref);\n    const oldVal = hostRef.$instanceValues$.get(propName);\n    const flags = hostRef.$flags$;\n    const instance = hostRef.$lazyInstance$ ;\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n    if ((!(flags & 8 /* isConstructingInstance */) || oldVal === undefined) && newVal !== oldVal) {\n        // gadzooks! the property's value has changed!!\n        // set our new value!\n        hostRef.$instanceValues$.set(propName, newVal);\n        if (instance) {\n            if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n                // looks like this value actually changed, so we've got work to do!\n                // but only if we've already rendered, otherwise just chill out\n                // queue that we need to do an update, but don't worry about queuing\n                // up millions cuz this function ensures it only runs once\n                scheduleUpdate(hostRef, false);\n            }\n        }\n    }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n    if (cmpMeta.$members$) {\n        // It's better to have a const than two Object.entries()\n        const members = Object.entries(cmpMeta.$members$);\n        const prototype = Cstr.prototype;\n        members.map(([memberName, [memberFlags]]) => {\n            if ((memberFlags & 31 /* Prop */ || ((flags & 2 /* proxyState */) && memberFlags & 32 /* State */))) {\n                // proxyComponent - prop\n                Object.defineProperty(prototype, memberName, {\n                    get() {\n                        // proxyComponent, get value\n                        return getValue(this, memberName);\n                    },\n                    set(newValue) {\n                        // proxyComponent, set value\n                        setValue(this, memberName, newValue, cmpMeta);\n                    },\n                    configurable: true,\n                    enumerable: true,\n                });\n            }\n        });\n        if ((flags & 1 /* isElementConstructor */)) {\n            const attrNameToPropName = new Map();\n            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n                plt.jmp(() => {\n                    const propName = attrNameToPropName.get(attrName);\n                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n                });\n            };\n            // create an array of attributes to observe\n            // and also create a map of html attribute name to js property name\n            Cstr.observedAttributes = members\n                .filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes\n                .map(([propName, m]) => {\n                const attrName = m[1] || propName;\n                attrNameToPropName.set(attrName, propName);\n                return attrName;\n            });\n        }\n    }\n    return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\n    // initializeComponent\n    if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n        {\n            // we haven't initialized this element yet\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // lazy loaded components\n            // request the component's implementation to be\n            // wired up with the host element\n            Cstr = loadModule(cmpMeta);\n            if (Cstr.then) {\n                // Await creates a micro-task avoid if possible\n                const endLoad = uniqueTime();\n                Cstr = await Cstr;\n                endLoad();\n            }\n            if (!Cstr.isProxied) {\n                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n                Cstr.isProxied = true;\n            }\n            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n            // ok, time to construct the instance\n            // but let's keep track of when we start and stop\n            // so that the getters/setters don't incorrectly step on data\n            {\n                hostRef.$flags$ |= 8 /* isConstructingInstance */;\n            }\n            // construct the lazy-loaded component implementation\n            // passing the hostRef is very important during\n            // construction in order to directly wire together the\n            // host element and the lazy-loaded instance\n            try {\n                new Cstr(hostRef);\n            }\n            catch (e) {\n                consoleError(e);\n            }\n            {\n                hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n            }\n            endNewInstance();\n        }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = () => scheduleUpdate(hostRef, true);\n    if (ancestorComponent && ancestorComponent['s-rc']) {\n        // this is the intial load and this component it has an ancestor component\n        // but the ancestor component has NOT fired its will update lifecycle yet\n        // so let's just cool our jets and wait for the ancestor to continue first\n        // this will get fired off when the ancestor component\n        // finally gets around to rendering its lazy self\n        // fire off the initial update\n        ancestorComponent['s-rc'].push(schedule);\n    }\n    else {\n        schedule();\n    }\n};\nconst connectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const cmpMeta = hostRef.$cmpMeta$;\n        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n            // first time this component has connected\n            hostRef.$flags$ |= 1 /* hasConnected */;\n            {\n                // initUpdate\n                // if the slot polyfill is required we'll need to put some nodes\n                // in here to act as original content anchors as we move nodes around\n                // host element has been connected to the DOM\n                if ((cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */))) {\n                    setContentReference(elm);\n                }\n            }\n            {\n                // find the first ancestor component (if there is one) and register\n                // this component as one of the actively loading child components for its ancestor\n                let ancestorComponent = elm;\n                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {\n                    // climb up the ancestors looking for the first\n                    // component that hasn't finished its lifecycle update yet\n                    if (ancestorComponent['s-p']) {\n                        // we found this components first ancestor component\n                        // keep a reference to this component's ancestor component\n                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));\n                        break;\n                    }\n                }\n            }\n            // Lazy properties\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n            if (cmpMeta.$members$) {\n                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n                        const value = elm[memberName];\n                        delete elm[memberName];\n                        elm[memberName] = value;\n                    }\n                });\n            }\n            {\n                initializeComponent(elm, hostRef, cmpMeta);\n            }\n        }\n        else {\n            // not the first time this has connected\n            // reattach any event listeners to the host\n            // since they would have been removed when disconnected\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);\n        }\n        endConnected();\n    }\n};\nconst setContentReference = (elm) => {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    const contentRefElm = (elm['s-cr'] = doc.createComment(''));\n    contentRefElm['s-cn'] = true;\n    elm.insertBefore(contentRefElm, elm.firstChild);\n};\nconst disconnectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        {\n            if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map(rmListener => rmListener());\n                hostRef.$rmListeners$ = undefined;\n            }\n        }\n    }\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n    const endBootstrap = createTime();\n    const cmpTags = [];\n    const exclude = options.exclude || [];\n    const customElements = win.customElements;\n    const head = doc.head;\n    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');\n    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');\n    const deferredConnectedCallbacks = [];\n    let appLoadFallback;\n    let isBootstrapping = true;\n    Object.assign(plt, options);\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n    lazyBundles.map(lazyBundle => lazyBundle[1].map(compactMeta => {\n        const cmpMeta = {\n            $flags$: compactMeta[0],\n            $tagName$: compactMeta[1],\n            $members$: compactMeta[2],\n            $listeners$: compactMeta[3],\n        };\n        {\n            cmpMeta.$members$ = compactMeta[2];\n        }\n        {\n            cmpMeta.$listeners$ = compactMeta[3];\n        }\n        const tagName = cmpMeta.$tagName$;\n        const HostElement = class extends HTMLElement {\n            // StencilLazyHost\n            constructor(self) {\n                // @ts-ignore\n                super(self);\n                self = this;\n                registerHost(self, cmpMeta);\n            }\n            connectedCallback() {\n                if (appLoadFallback) {\n                    clearTimeout(appLoadFallback);\n                    appLoadFallback = null;\n                }\n                if (isBootstrapping) {\n                    // connectedCallback will be processed once all components have been registered\n                    deferredConnectedCallbacks.push(this);\n                }\n                else {\n                    plt.jmp(() => connectedCallback(this));\n                }\n            }\n            disconnectedCallback() {\n                plt.jmp(() => disconnectedCallback(this));\n            }\n            componentOnReady() {\n                return getHostRef(this).$onReadyPromise$;\n            }\n        };\n        cmpMeta.$lazyBundleId$ = lazyBundle[0];\n        if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n            cmpTags.push(tagName);\n            customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\n        }\n    }));\n    {\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n        visibilityStyle.setAttribute('data-styles', '');\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n    // Process deferred connectedCallbacks now all components have been registered\n    isBootstrapping = false;\n    if (deferredConnectedCallbacks.length) {\n        deferredConnectedCallbacks.map(host => host.connectedCallback());\n    }\n    else {\n        {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));\n        }\n    }\n    // Fallback appLoad event\n    endBootstrap();\n};\nconst hostRefs = new WeakMap();\nconst getHostRef = (ref) => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);\nconst registerHost = (elm, cmpMeta) => {\n    const hostRef = {\n        $flags$: 0,\n        $hostElement$: elm,\n        $cmpMeta$: cmpMeta,\n        $instanceValues$: new Map(),\n    };\n    {\n        hostRef.$onReadyPromise$ = new Promise(r => (hostRef.$onReadyResolve$ = r));\n        elm['s-p'] = [];\n        elm['s-rc'] = [];\n    }\n    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);\n    return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = (e, el) => (0, console.error)(e, el);\nconst cmpModules = /*@__PURE__*/ new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n    // loadModuleImport\n    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n    const bundleId = cmpMeta.$lazyBundleId$;\n    const module = cmpModules.get(bundleId) ;\n    if (module) {\n        return module[exportName];\n    }\n    return import(\n    /* webpackInclude: /\\.entry\\.js$/ */\n    /* webpackExclude: /\\.system\\.entry\\.js$/ */\n    /* webpackMode: \"lazy\" */\n    `./${bundleId}.entry.js${''}`).then(importedModule => {\n        {\n            cmpModules.set(bundleId, importedModule);\n        }\n        return importedModule[exportName];\n    }, consoleError);\n};\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueTask = (queue, write) => (cb) => {\n    queue.push(cb);\n    if (!queuePending) {\n        queuePending = true;\n        if (write && plt.$flags$ & 4 /* queueSync */) {\n            nextTick(flush);\n        }\n        else {\n            plt.raf(flush);\n        }\n    }\n};\nconst consume = (queue) => {\n    for (let i = 0; i < queue.length; i++) {\n        try {\n            queue[i](performance.now());\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    queue.length = 0;\n};\nconst flush = () => {\n    // always force a bunch of medium callbacks to run, but still have\n    // a throttle on how many can run in a certain time\n    // DOM READS!!!\n    consume(queueDomReads);\n    // DOM WRITES!!!\n    {\n        consume(queueDomWrites);\n        if ((queuePending = queueDomReads.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n    }\n};\nconst nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\n\nexport { Host as H, bootstrapLazy as b, getElement as g, h, promiseResolve as p, registerInstance as r };\n"],"sourceRoot":""}